-- Migration: Daily Challenges
-- Description: Create table for storing daily coding challenges
-- Date: 2025-11-21

-- ============================================================================
-- 1. Create Daily Challenges Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS daily_challenges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  date DATE NOT NULL,
  language TEXT NOT NULL CHECK (language IN ('python', 'javascript', 'typescript', 'java', 'cpp', 'csharp', 'go')),
  problem JSONB NOT NULL,
  test_cases JSONB NOT NULL,
  difficulty TEXT CHECK (difficulty IN ('easy', 'medium', 'hard')),
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- 2. Create Indexes
-- ============================================================================

-- Unique index to ensure one challenge per date per language
CREATE UNIQUE INDEX IF NOT EXISTS idx_daily_challenges_date_language 
ON daily_challenges(date, language);

-- Index for date lookups (most common query)
CREATE INDEX IF NOT EXISTS idx_daily_challenges_date 
ON daily_challenges(date DESC);

-- Index for language-specific queries
CREATE INDEX IF NOT EXISTS idx_daily_challenges_language 
ON daily_challenges(language);

-- ============================================================================
-- 3. Add Comments for Documentation
-- ============================================================================

COMMENT ON TABLE daily_challenges IS 'Stores daily coding challenges generated by AI for each programming language';
COMMENT ON COLUMN daily_challenges.date IS 'Date of the challenge (one challenge per language per day)';
COMMENT ON COLUMN daily_challenges.language IS 'Programming language for the challenge';
COMMENT ON COLUMN daily_challenges.problem IS 'Challenge problem description and requirements (JSON format)';
COMMENT ON COLUMN daily_challenges.test_cases IS 'Test cases for validating solutions (JSON format)';
COMMENT ON COLUMN daily_challenges.difficulty IS 'Challenge difficulty level';
COMMENT ON COLUMN daily_challenges.metadata IS 'Additional metadata (tags, topics, estimated time, etc.)';

-- ============================================================================
-- 4. Create User Challenge Attempts Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS user_challenge_attempts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  challenge_id UUID REFERENCES daily_challenges(id) ON DELETE CASCADE,
  code TEXT NOT NULL,
  language TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('pending', 'passed', 'failed')),
  execution_time_ms INTEGER,
  test_results JSONB,
  submitted_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, challenge_id)
);

-- Indexes for user attempts
CREATE INDEX IF NOT EXISTS idx_user_attempts_user_id 
ON user_challenge_attempts(user_id);

CREATE INDEX IF NOT EXISTS idx_user_attempts_challenge_id 
ON user_challenge_attempts(challenge_id);

CREATE INDEX IF NOT EXISTS idx_user_attempts_status 
ON user_challenge_attempts(user_id, status);

COMMENT ON TABLE user_challenge_attempts IS 'Tracks user attempts at daily challenges';
COMMENT ON COLUMN user_challenge_attempts.status IS 'Status of the attempt: pending (not submitted), passed (all tests passed), failed (some tests failed)';

-- ============================================================================
-- 5. Helper Functions
-- ============================================================================

-- Function to get today's challenge for a specific language
CREATE OR REPLACE FUNCTION get_todays_challenge(p_language TEXT)
RETURNS TABLE (
  id UUID,
  date DATE,
  language TEXT,
  problem JSONB,
  test_cases JSONB,
  difficulty TEXT,
  metadata JSONB
) AS $
BEGIN
  RETURN QUERY
  SELECT 
    dc.id,
    dc.date,
    dc.language,
    dc.problem,
    dc.test_cases,
    dc.difficulty,
    dc.metadata
  FROM daily_challenges dc
  WHERE dc.date = CURRENT_DATE
    AND dc.language = p_language
  LIMIT 1;
END;
$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION get_todays_challenge IS 'Retrieves today''s challenge for a specific programming language';

-- Function to get user's challenge statistics
CREATE OR REPLACE FUNCTION get_user_challenge_stats(p_user_id UUID)
RETURNS TABLE (
  total_attempts INTEGER,
  passed_challenges INTEGER,
  failed_challenges INTEGER,
  current_streak INTEGER,
  longest_streak INTEGER
) AS $
DECLARE
  v_current_streak INTEGER := 0;
  v_longest_streak INTEGER := 0;
  v_temp_streak INTEGER := 0;
  v_prev_date DATE;
  v_curr_date DATE;
BEGIN
  -- Count total attempts and passed/failed
  SELECT 
    COUNT(*),
    COUNT(*) FILTER (WHERE status = 'passed'),
    COUNT(*) FILTER (WHERE status = 'failed')
  INTO total_attempts, passed_challenges, failed_challenges
  FROM user_challenge_attempts
  WHERE user_id = p_user_id;
  
  -- Calculate streaks (consecutive days with passed challenges)
  FOR v_curr_date IN 
    SELECT DISTINCT DATE(submitted_at)
    FROM user_challenge_attempts
    WHERE user_id = p_user_id AND status = 'passed'
    ORDER BY DATE(submitted_at) DESC
  LOOP
    IF v_prev_date IS NULL OR v_prev_date - v_curr_date = 1 THEN
      v_temp_streak := v_temp_streak + 1;
      v_longest_streak := GREATEST(v_longest_streak, v_temp_streak);
      
      -- Current streak only counts if it includes today or yesterday
      IF v_curr_date >= CURRENT_DATE - INTERVAL '1 day' THEN
        v_current_streak := v_temp_streak;
      END IF;
    ELSE
      v_temp_streak := 1;
    END IF;
    
    v_prev_date := v_curr_date;
  END LOOP;
  
  RETURN QUERY SELECT 
    COALESCE(total_attempts, 0)::INTEGER,
    COALESCE(passed_challenges, 0)::INTEGER,
    COALESCE(failed_challenges, 0)::INTEGER,
    v_current_streak,
    v_longest_streak;
END;
$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION get_user_challenge_stats IS 'Calculates user statistics for daily challenges including streaks';

-- Function to update timestamp on row update
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- 6. Triggers
-- ============================================================================

-- Trigger to update updated_at timestamp
CREATE TRIGGER trigger_daily_challenges_updated_at
BEFORE UPDATE ON daily_challenges
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- 7. Row Level Security (RLS)
-- ============================================================================

ALTER TABLE daily_challenges ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_challenge_attempts ENABLE ROW LEVEL SECURITY;

-- Daily challenges policies (read-only for all authenticated users)
CREATE POLICY "Anyone can view daily challenges" ON daily_challenges
  FOR SELECT USING (true);

-- Only system/admin can insert/update challenges (via API with service role)
CREATE POLICY "Service role can insert challenges" ON daily_challenges
  FOR INSERT WITH CHECK (true);

CREATE POLICY "Service role can update challenges" ON daily_challenges
  FOR UPDATE USING (true);

-- User challenge attempts policies
CREATE POLICY "Users can view own attempts" ON user_challenge_attempts
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own attempts" ON user_challenge_attempts
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own attempts" ON user_challenge_attempts
  FOR UPDATE USING (auth.uid() = user_id);

-- ============================================================================
-- Migration Complete
-- ============================================================================
